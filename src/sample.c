/*
 * =====================================================================================
 * *       Filename:  test.c
 *
 *    Description:  
 *
 *        Version:  1.0
 *        Created:  07/22/2011 03:02:38 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *        Company:  
 *
 * =====================================================================================
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "SR_Common/SR_Error.h"
#include "SR_Map/SR_Reference.h"
#include "SR_Map/SR_HashRegionTable.h"
#include "SR_Map/SR_Utilities.h"

#define TEST_TIME 1000000

#define SEARCH_REGION 10000

#define DEL_LEN 500

#define REF_LEN 1000000

void InitSimQueryRegion(QueryRegion* pQueryRegion, const SR_Reference* pRef, unsigned short queryLen, unsigned int searchRegion, unsigned int delLen);

int main(int argc, char *argv[])
{
    // this is the reference file generated by "SR_Build" program
    FILE* refInput = fopen(argv[1], "rb");
    if (refInput == NULL)
        SR_ErrSys("ERROR: Cannot open reference input file %s.\n", argv[1]);

    // allocate a reference object
    // the parameter give here is the capacity of this object
    // ususally it should be the length of the largest chromosome, say chr1
    SR_Reference* pRef = SR_ReferenceAlloc(REF_LEN);

    // this is the hashtable file generated by "SR_Build" program
    FILE* hashTableInput = fopen(argv[2], "rb");
    if (hashTableInput == NULL)
        SR_ErrSys("ERROR: Cannot open hash table input file %s.\n", argv[2]);

    // read the hash size from the hash table file
    unsigned short hashSize = 0;
    READ_HASH_SIZE(hashSize, hashTableInput);

    // create a hashtable object
    SR_InHashTable* pHashTable = SR_InHashTableAlloc(hashSize);

    // create a hash region table object
    // the parameter given here is the edge tolerance percentage which is not useful here
    HashRegionTable* pRegionTable = HashRegionTableAlloc(0.25);

    // boolean variables to control the process
    Bool keepGoing = TRUE;
    Bool readRef = TRUE;
    Bool readHashTable = TRUE;

    do
    {
        // read the reference sequence chromosome by chromosome
        if (readRef) {
            keepGoing = SR_ReferenceRead(pRef, refInput);
	    if ( !keepGoing ) break;
	}

        // read the hash table chromosome by chromosome
        if (readHashTable)
            keepGoing = SR_InHashTableRead(pHashTable, hashTableInput);

        if (pRef->chr == pHashTable->chr)
        {
            // do partial alignment
            // load the read and do the alignment for the current chromosome
            
            readRef = TRUE;
            readHashTable = TRUE;
        }
        else if (pRef->chr < pHashTable->chr)
        {
            readRef = TRUE;
            readHashTable = FALSE;
        }
        else
        {
            readRef = FALSE;
            readHashTable =TRUE;
        }

    }while(keepGoing);


    // free the objects and close files
    SR_InHashTableFree(pHashTable);
    HashRegionTableFree(pRegionTable);
    SR_ReferenceFree(pRef);
    fclose(refInput);
    fclose(hashTableInput);

    return EXIT_SUCCESS;
}


void InitSimQueryRegion(QueryRegion* pQueryRegion, const SR_Reference* pRef, unsigned short queryLen, unsigned int searchLen, unsigned int delLen)
{
    unsigned int pos = rand() % (pRef->length - 2 * searchLen - queryLen + 1);

    char refBuff[77];
    refBuff[76] = '\0';

    strncpy( (char*) pQueryRegion->query, pRef->sequence + pos + searchLen, queryLen / 2);
    strncpy(refBuff, pRef->sequence + pos + searchLen, queryLen / 2);

    strncpy((char*) pQueryRegion->query + queryLen / 2, pRef->sequence + pos + searchLen + delLen, queryLen / 2);
    strncpy(refBuff + queryLen / 2, pRef->sequence + pos + searchLen + delLen, queryLen / 2);

    if (strcmp(pQueryRegion->query, refBuff) != 0)
        SR_ErrQuit("ERROR: not the same");

    //printf("%s\n", pQueryRegion->query);

    /*  
    for (int i = 0; i != queryLen / 2; ++i)
        putchar(*(pRef->sequence + pos + searchLen + i));

    for (int i = 0; i != queryLen / 2; ++i)
        putchar(*(pRef->sequence + pos + searchLen + delLen + i));

    putchar('\n');
    */

    pQueryRegion->queryLen = queryLen;
    pQueryRegion->refBegin = pos;
    pQueryRegion->closeRefBound = pos + 2 * searchLen + queryLen - 1;
    pQueryRegion->farRefBound = pQueryRegion->closeRefBound;
}
